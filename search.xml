<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>程序是怎样跑起来的</title>
      <link href="/posts/d0e4df87643b/"/>
      <url>/posts/d0e4df87643b/</url>
      
        <content type="html"><![CDATA[<h3 id="高级程序语言中变量的数据类型表示的意义是什么？"><a href="#高级程序语言中变量的数据类型表示的意义是什么？" class="headerlink" title="高级程序语言中变量的数据类型表示的意义是什么？"></a>高级程序语言中变量的数据类型表示的意义是什么？</h3><blockquote><p>数据类型有两个作用</p><ul><li><p>占用内存空间的大小</p></li><li><p>如何解释内存数据</p><hr><p>变量是内存地址的抽象</p></li></ul></blockquote><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><blockquote><p>使用栈结构很好的解决了函数调用（在执行前将函数指令的下一个地址入栈，指令执行完毕，地址出栈，CPU即可知道下一个指令的地址）和内存地址管理，后调的函数必然先销毁，所以对应的临时变量（内存地址）也需要先回收（变量的生命周期[GC的引用计数]）。这就是栈！</p></blockquote><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><blockquote><p>协调好输入与处理时机之间的关系，排队的机制是很方便的。</p><p>在内存上，实现这种机制的方式就是队列。当我们需要处理通讯中发送的数据时，或由同时运行的多个程序所发送过来的数据时，会用到这种对队列中存储的不规则数据进行处理的方法。</p><p>队列一般是以环状缓冲区（ring buffer）的方式来实现的。</p><p>排成纵队，从队头出队，从队尾入队，随着不停的出队，由于队伍没有整体前移，腾出来的无效内存越来越多。排成环队，队尾追队头，随着出队，腾出来的内存可被用来入队，节约内存。</p></blockquote><p>今天看完了《程序是怎样跑起来的》这本书，总算对程序以及程序背后的运行机制的概念有了一些新的认识，也消除了一些疑问。</p><h3 id="为什么计算机是二进制？"><a href="#为什么计算机是二进制？" class="headerlink" title="为什么计算机是二进制？"></a>为什么计算机是二进制？</h3><p>数据在计算机的存储，执行，在芯片内部都是一个个电路开关，0与1实际上是物理电信号高低电位的映射。为了解决负数计算如<code>1 + (-1)</code>，于是产生了补码。二进制与十进制，都是对同一种数据的不同表达形式，而计算机内部使用二进制，是与其内部构造使用高低电位来表达两种状态而选择的最恰当的方式。</p><h3 id="补码从何而来？"><a href="#补码从何而来？" class="headerlink" title="补码从何而来？"></a>补码从何而来？</h3><p>补码从何而来？存在即合理，不如换个角度思考，补码的存在是为了解决什么问题。</p><p>它的存在是为了解决计算机的减法问题。</p><p>举个简单的例子，我们都知道<code>1 + (-1) == 0</code>，然而二进制该怎样表达这个等式呢？我们都知道计算机只能执行加法运算，也知道减法在计算机中也是加法，只是加了负数。可是，这样的负数如何才能得到呢？有人会说二进制数有符号位，正数的符号为为<code>0</code>，负数为<code>1</code>，<code>-1</code>可以表示成<code>1000 0001</code>，但是显然，<code>0000 0001 + 1000 0001 != 0000 0000</code>。这样的计算结果是错误的 。所以我们需要一种新的表达方式，利用计算溢出，于是有了<strong>补码</strong>。</p><p><code>1</code>的二进制表示为<code>0000 0001</code>，<code>-1</code>用<code>?</code>表示，则有<code>0000 0001 + ? == 0000 0000</code>。</p><p>那么利用计算机的最高位溢出特性，显然可以知道<code>-1</code>的补码为<code>1111 1111</code>。</p><p>如此，<code>0000 0001 + 1111 1111 == 0000 0000</code>就成立了，<strong>因为高位的1被舍弃了</strong>。</p><p>更一般的，设二进制数<code>x</code>，<code>x &gt; 0</code>，则<code>-x</code>的补码为<code>!x + 1</code>，也就是<code>x</code>的各位取反后加1。</p><p>以<code>1</code>为例，<code>1</code>的二进制为<code>0000 0001</code>，根据以上公式我们可得<code>-1 == !(1) + 1 == 1111 1110 + 1 == 1111 1111</code>。</p><p>如此就得出了负数的补码。</p><p>那么正数呢？</p><p>我们已经知道，补码的发明，解决了计算机的减法问题，解决了负数在计算机的表达问题。</p><p>对于正数，补码就是其本身。</p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>应对生活中的小数，计算机也有浮点数表达方式。在32位的数据中，IEEE规定了浮点数的表达方式，其中1位符号位，8位指数位23位尾数。这曾经浮点数也让我产生了一些错误认知，我一度以为它在计算机内可以表示任意数值，因为数学告诉我在非0长度的区间，数应该是无限的。但现在才能理解，32位数据这意味着其表示范围只有2^32个数，并不是无限的。二进制浮点数不可能表示任意小数，它也面临着精度问题，就像十进制小数也不能准确表达1&#x2F;3一样。</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>由于计算机只能处理数字，所以人类生活中的字符，符号，全都靠的是编码映射。这也是计算机擅长的处理方式。</p><h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><p>函数的调用栈，目的是切换指令的上下文环境，解决了程序执行顺序的问题。也帮助了寄存器清除局部变量。</p><h3 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h3><p>内存造价昂贵，数据读取速度快，而硬盘较为低廉，数据读取速度慢。但较为低廉这意味着我们花同样的价钱，可以买到容量较大的硬盘。我们可以把文件、程序存储在硬盘，需要用到时再读取内存让cpu运行计算。<br>扇区是硬盘物理读写的最小单位，一个扇区一般为512字节。在windows中，硬盘读写单位是扇区的整数倍，称为簇，不同的文件不能存放在同一簇中。因此不管是多小的文件，都会占用1簇的空间。所以你会发现如果一个文件夹里有非常多的细碎小文件并且总共容量很大的话，无论是对这个文件夹进行复制或是删除操作，花费的时间都相对漫长，但如果把文件夹打包成压缩包形成一个整体再进行复制或是删除操作，速度将大大加快。</p><h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p>数据含有重复表达的信息，这意味着浪费了内存，于是为了降低这样的浪费，就有人提出了数据压缩。数据压缩分为可逆压缩和非可逆压缩。比如图片有损压缩方面，如jpg格式等，压缩数据基本不会影响图片效果，同里也有音频的mp3格式等。但文本数据以及程序则必须使用可逆压缩，否则原有的信息缺失将无法得到正确的表达。<a href="/posts/cl3emxu3c0006s8kmgj3l9q3f/">哈夫曼编码</a>则是经典的可逆压缩算法。</p><h3 id="程序跨平台"><a href="#程序跨平台" class="headerlink" title="程序跨平台"></a>程序跨平台</h3><p>程序不能直接操作硬件，而是调用操作系统提供的接口进行间接操作。不同CPU架构的指令集可能不同，这也就意味着编译出的程序在不同操作系统下可能无法正常运行，因为指令集无法正确被其CPU处理，于是延伸出了程序如何实现跨平台运行的问题。跨平台有两种方式，源码级别的跨平台以及虚拟环境的跨平台。源码级别的跨平台，在Unix的FreeBSD存在一种叫做Ports的机制，能够根据当前的运行环境来编译出对应系统能够运行的本地代码。简称一次编写，到处编译。<br>这种方式略微繁琐，于是又出现了虚拟运行环境的东西，如Java的虚拟机。Java编译后会产生统一的字节码，我的理解是字节码就相当于为指令集提供了一种抽象，而Java在不同操作系统都提供了Java虚拟机，它负责把字节码转变为对应架构的指令集，转译成本地代码。相当于Java虚拟机代替我们完成了Ports的机制处理，实现了一次编写，到处运行。然而Java的二次转译也意味着同样流程的程序分别使用C&#x2F;C++与Java编写，执行效率一般来说不会超过C&#x2F;C++这样不需要经过二次转译的语言。</p><h3 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h3><p>程序也占内存，浩如烟海的程序中往往也有很多实现了同样逻辑的api。这样数据就造成了冗余，浪费了内存。于是在windows中，动态链接库DLL解决了这样的问题。只需要提供了完成某些功能封装好的api，开发者只需要使用其api即可顺利完成其功能，并且所有需要实现此功能的程序都可以共同使用这个DLL，这也就减少了内存浪费。并且可以做到功能的局部更新（只需要更新相应的DLL文件即可）。</p><h3 id="伪随机数"><a href="#伪随机数" class="headerlink" title="伪随机数"></a>伪随机数</h3><p>随机数也并不是真随机，而是借助计算公式得出。如果提供一致的参数，理论上可以推演出下一步的结果。</p><h3 id="中断信号"><a href="#中断信号" class="headerlink" title="中断信号"></a>中断信号</h3><p>中断是异步编程的通信方式。CPU一旦接到中断型号，就会把寄存器中所有的数据保存在内存的栈中，然后执行中断处理程序。执行中断程序完毕后，则将栈中数据弹出。这样就完成了上下文的切换。而为了防止多个设备同时进行中断请求，所以计算机引入了中断控制器来进行缓冲，将中断请求有序的传递给CPU。</p><hr><p>看完这本书，大概花了我大半个月的时间，我几乎是在这本书中重新学了一遍计算机组成原理。我知道这本书里面的很多内容其实没有细致的讲解，但至少让我对程序是如何跑起来这一个概念有了一些认识，我觉得还是有所收获的。面对计算机底层知识，也不会再让我恐惧。</p><p>大一大二时我一直不太理解为什么我一个学习软件的，还要去了解硬件层面的知识。现在我大概明白，我曾经追求的各种新鲜技术，各种的猎奇。这只不过是学习上层提供的各种api，拿着他们已经做好的工具，去搭积木。提供积木的品牌很多，但仅仅局限于使用这样的积木，自始自终，我也不会有朝一日实现自己积木的那一天。<br>上层的工具时刻都在变化，而不便的，永远是下层建筑最经典的智慧。</p><p>或许这篇日后还会更新呢? 我也很期待~</p><h3 id="碎碎话"><a href="#碎碎话" class="headerlink" title="碎碎话"></a>碎碎话</h3><blockquote><p>每一次伟大的认知，都源于对这个世界的不解。</p></blockquote><p><em>2022年5月22日于寝室</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼树的构建</title>
      <link href="/posts/94070ea5df57/"/>
      <url>/posts/94070ea5df57/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E6%98%AF%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E7%9A%84">哈夫曼树是如何构建的？</a><ul><li><a href="#%E5%AD%97%E7%AC%A6%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%AD%98%E5%9C%A8%E5%BD%A2%E5%BC%8F">字符在计算机中的存在形式</a></li><li><a href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E6%98%AF%E7%94%A8%E6%9D%A5%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84">哈夫曼编码是用来干什么的？</a></li><li><a href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8E%8B%E7%BC%A9%E7%9A%84%E5%91%A2">哈夫曼编码是如何实现压缩的呢？</a></li><li><a href="#%E6%9E%84%E5%BB%BA%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91">构建哈夫曼树</a></li><li><a href="#%E8%AE%A1%E7%AE%97%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81todo-%E5%A4%9C%E5%B7%B2%E6%B7%B1-%E5%85%88%E7%9D%A1%E8%A7%89%E4%BA%86-%E9%86%92%E5%90%8E%E6%9B%B4%E6%96%B020220518-done">计算哈夫曼编码（<del>Todo, 夜已深, 先睡觉了, 醒后更新</del>，2022&#x2F;05&#x2F;18 done）</a></li><li><a href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B">简单示例</a></li><li><a href="#%E9%81%BF%E5%85%8D%E6%B5%AA%E8%B4%B9">避免浪费</a></li><li><a href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C">运行结果</a></li><li><a href="#%E7%A2%8E%E7%A2%8E%E8%AF%9D">碎碎话</a></li></ul></li></ul><h1 id="哈夫曼树是如何构建的？"><a href="#哈夫曼树是如何构建的？" class="headerlink" title="哈夫曼树是如何构建的？"></a>哈夫曼树是如何构建的？</h1><p>今天在《程序是怎样跑起来的》一书中提及了哈夫曼编码的构建过程。突然回忆起第一次接触哈夫曼编码还是两年前的大一，那时连二叉树都不懂，更别提什么哈夫曼编码了。但是如今看了书中的构建思路，我已经有了大致的代码实现思路，立刻趁着思绪泉涌，赶紧打开vscode，把脑子里的构象一步步的敲下来。完成之后，运行调试，符合预期，大喜，欣欣然~</p><p>趁着兴奋的状态还未消去，赶紧写下此篇文章，以加深记忆。</p><h3 id="字符在计算机中的存在形式"><a href="#字符在计算机中的存在形式" class="headerlink" title="字符在计算机中的存在形式"></a>字符在计算机中的存在形式</h3><p>我们都知道，一个半角字符占用一个字节(byte)，也就是8比特(bit)。一个全角字符占用2个字节。（一个汉字为一个全角）</p><blockquote><p><img src="https://pic.imgdb.cn/item/6287778409475431296037f5.png" alt="album_temp_1652800133"></p><p><em>《程序是怎样跑起来的》图6-1</em></p></blockquote><p>那么数据压缩本质是什么？其实就是减少重复数据。压缩效率越高，意味着对重复数据的利用率也越高。</p><p>那么，</p><h3 id="哈夫曼编码是用来干什么的？"><a href="#哈夫曼编码是用来干什么的？" class="headerlink" title="哈夫曼编码是用来干什么的？"></a>哈夫曼编码是用来干什么的？</h3><p>它也是一种压缩算法。</p><h3 id="哈夫曼编码是如何实现压缩的呢？"><a href="#哈夫曼编码是如何实现压缩的呢？" class="headerlink" title="哈夫曼编码是如何实现压缩的呢？"></a>哈夫曼编码是如何实现压缩的呢？</h3><p>数据中出现数据重复度最高字符（即出现频率高）的我们选用一种长度尽可能短的编码替换，字符重复度低（即出现频率低）则选用长度较长的编码替换。由于出现频率高的字符都使用了短编码，频率低的字符选用较长的编码。那么显而易见，如此处理后的数据占据空间会比原数据的空间要小，也就实现了数据压缩。</p><h3 id="构建哈夫曼树"><a href="#构建哈夫曼树" class="headerlink" title="构建哈夫曼树"></a>构建哈夫曼树</h3><blockquote><p><img src="https://pic.imgdb.cn/item/6287778409475431296037f8.png" alt="album_temp_1652804549"></p><p><em>《程序是怎样跑起来的》图6-5 哈夫曼树的编码顺序</em></p></blockquote><p>大致步骤书中已给出，但图中最终构建的哈夫曼树与我自己的程序构建的略有不同，若要实现图中的树结构，似乎还需要进行一些状态压缩处理，但我的算法属于其简化版，并没有状态压缩部分的内容，但对于理解哈夫曼编码的目的应该达到了。</p><p>接下来我们看看如何编码。</p><p>既然需要得知字符串的出现频率（比较出现次数即可），那么自然需要统出除各个字符在字符串中出现的次数。</p><p>以字符串<code>string s = &quot;AAAAAABBCDDEEEEEF&quot;;</code>为例。</p><p>我们使用一个哈希表<code>map&lt;char, int&gt; table;</code>来记录各个字符在<code>s</code>出现的次数。</p><p>通过遍历<code>s</code>，我们可以得到<code>table</code>数据如下：</p><table><thead><tr><th>字符</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr></thead><tbody><tr><td>频数</td><td>6</td><td>2</td><td>1</td><td>2</td><td>5</td><td>1</td></tr></tbody></table><p>书中提到了需要将<code>table</code>按频数进行排序。</p><p>由于书中步骤二每一次都需要选出两个频率最小的数，在两数合并成一个数后有需要回到其队列。</p><p>那么我们不妨使用优先队列来模拟这样的操作。根据优先队列的性质，每一次将元素入队，优先队列都会按照其元素权重放入其应该放入的位置。如此一来，我们避免了每次都需要用手动排序来保证元素顺序，只需要处理入队出队即可。</p><p>我们约定了一个<code>TreeNode</code>对象来描述哈夫曼树结点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> weight; <span class="comment">// 字符权重</span></span><br><span class="line">    <span class="type">char</span> data; <span class="comment">// 字符</span></span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> weight, <span class="type">char</span> data) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data = data;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> weight, <span class="type">char</span> data, TreeNode* left, TreeNode* right) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data = data;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = left;</span><br><span class="line">        <span class="keyword">this</span>-&gt;right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">TreeNode</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;TreeNode -&gt; weight: &quot;</span> &lt;&lt;  <span class="keyword">this</span>-&gt;weight &lt;&lt; <span class="string">&quot; has been released.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以下就是构建哈夫曼树的核心代码<code>build</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优先队列自定义排序，权重高的向后排（优先队列默认权重越高越前，为了其权重越低越在前，所以这里反了过来使用了&gt;）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(TreeNode* a, TreeNode* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;weight &gt; b-&gt;weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造一颗哈夫曼数</span></span><br><span class="line">    <span class="comment">// 首先需要统计字符串出现的次数</span></span><br><span class="line">    map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; _map;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span>&amp; c : s) _map[c]++;</span><br><span class="line">    <span class="comment">// 使用一个优先队列来维护权值的位置关系，</span></span><br><span class="line">    priority_queue&lt;TreeNode*, vector&lt;TreeNode*&gt;, cmp&gt; que;</span><br><span class="line">    <span class="comment">// 将每个元素构建成TreeNode，进行入队</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pack : _map) &#123;</span><br><span class="line">        <span class="type">int</span> data = pack.first;</span><br><span class="line">        <span class="type">char</span> val = pack.second;</span><br><span class="line">        que.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">TreeNode</span>(val, data));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自底向上构造哈夫曼树，每次合并都会减少队列中的一个元素（2个元素合并成1个元素），当优先队列仅剩一个元素时，此时这个元素就是哈夫曼树的根节点</span></span><br><span class="line">    <span class="keyword">while</span> (que.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        TreeNode* node1 = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        TreeNode* node2 = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> weight = node1-&gt;weight + node2-&gt;weight;</span><br><span class="line">        <span class="comment">// 每一次合并，都构建一个新的TreeNode，并将用于合并的两个结点作为其左右子树，合并后的TreeNode使用 &#x27;\0&#x27; 区分</span></span><br><span class="line">        que.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">TreeNode</span>(weight, <span class="string">&#x27;\0&#x27;</span>, node1, node2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回哈夫曼根节点</span></span><br><span class="line">    <span class="keyword">return</span> que.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样，一颗哈夫曼树就构建完成了，可是单单构建还不够，我们需要利用这颗哈夫曼树得出哈夫曼编码。</p><p>我们都知道，哈夫曼树只需要统一在左右子树的树枝上标记0、1，然后从根节点一路向下进行标记，路径一直记录到叶子结点，那么这个路径即为当前字符的哈夫曼编码。</p><p>如图（绿色代表合成结点，蓝色代表原生的字符结点，蓝色底部文字代表其对应的哈夫曼编码，很显然，字符结点均为叶子结点）：</p><p><img src="https://pic.imgdb.cn/item/628777840947543129603800.png" alt="Xnip2022-05-18_00-00-56"></p><p>所以，我们要如何才能计算出哈夫曼编码呢？</p><h3 id="计算哈夫曼编码（Todo-夜已深-先睡觉了-醒后更新，2022-x2F-05-x2F-18-done）"><a href="#计算哈夫曼编码（Todo-夜已深-先睡觉了-醒后更新，2022-x2F-05-x2F-18-done）" class="headerlink" title="计算哈夫曼编码（Todo, 夜已深, 先睡觉了, 醒后更新，2022&#x2F;05&#x2F;18 done）"></a>计算哈夫曼编码（<del>Todo, 夜已深, 先睡觉了, 醒后更新</del>，2022&#x2F;05&#x2F;18 done）</h3><p>我们已经知道，哈夫曼编码是由其0、1映射成的路径构成。我们要获得其字符的哈夫曼编码，就需要通过遍历这个哈夫曼树实现。</p><p>既然是遍历二叉树，那很自然的想到二叉树有三种经典的遍历方式，分别树前、中、后序遍历。但其实这里无所谓哪种方式，都是可行的。</p><p>这里我用的是前序遍历的方式，使用递归调用实现。</p><p>我们假定该函数名为<code>dfs</code>。</p><p>我们需要给递归函数提供哪些参数？</p><ul><li><p><code>TreeNode* node</code>，毫无疑问，遍历二叉树自然需要提供结点参数，即<code>node</code>。</p></li><li><p><code>string path</code>，我们需要得到叶子结点的哈夫曼编码，也就是需要记录根节点到其叶子结点的访问路径。那么需要一个额外参数<code>path</code>来记录访问路径。</p></li><li><p><code>map&lt;char, string&gt;&amp; huffman_code_table</code>，我们需要有一个哈希表<code>huffman_code_table</code>来记录字符对应的编码。</p></li></ul><p>那么函数签名应为<code>void dfs(TreeNode* node, string path，map&lt;char, string&gt;&amp; huffman_code_table)</code>。</p><p>那么如何递归呢？</p><p>第一步，需要给递归函数一个<code>base case</code>，即终止递归的条件。当<code>node</code>为<code>nullptr</code>时自然就不需要继续递归了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node, string path，map&lt;<span class="type">char</span>, string&gt;&amp; huffman_code_table)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">/** pass */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，若当前结点是叶子结点时，也就意味着当前的<code>node</code>就是字符所在的结点。那么我们就要在编码表<code>huffman_code_table</code>中，将<code>path</code>与字符<code>node-&gt;data</code>建立起映射关系了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node, string path，map&lt;<span class="type">char</span>, string&gt;&amp; huffman_code_table)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) &#123;</span><br><span class="line">    huffman_code_table[node-&gt;data] = path;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** pass */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，如果<code>node</code>不为<code>nullptr</code>，且<code>node-&gt;left</code>或者<code>node-&gt;right</code>不为<code>nullptr</code>，这意味着<code>node</code>不是叶子结点，意味着它们是路径上的结点。所以我们需要往其左右结点继续向下搜索，并且在搜索的同时记录当前的路径。进行递归搜索。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node, string path，map&lt;<span class="type">char</span>, string&gt;&amp; huffman_code_table)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) &#123;</span><br><span class="line">    huffman_code_table[node-&gt;data] = path;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(node-&gt;left, path + <span class="string">&quot;0&quot;</span>);</span><br><span class="line">  <span class="built_in">dfs</span>(node-&gt;right, path + <span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，<code>dfs</code>就算写完了，当<code>dfs</code>接受到哈夫曼树的头结点后，它就会不断的搜索、记录路径，一旦遇到字符所在结点，就开始建立字符与编码的映射关系。</p><p>由于<code>dfs</code>是一个递归函数，我们需要创建一个额外的函数<code>generate_huffman_code</code>并且借助之前写好的<code>build</code>调用它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">map&lt;<span class="type">char</span>, string&gt; <span class="title">generate_huffman_code</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">char</span>, string&gt; huffman_code_table;</span><br><span class="line">  <span class="comment">// 根据s构建哈夫曼树</span></span><br><span class="line">    TreeNode* root = <span class="built_in">build</span>(s);</span><br><span class="line">    <span class="comment">// 对哈夫曼树进行深度遍历构建哈夫曼编码</span></span><br><span class="line">    <span class="built_in">dfs</span>(root, <span class="string">&quot;&quot;</span>, huffman_code_table);</span><br><span class="line">  <span class="comment">// 返回哈夫曼编码映射表</span></span><br><span class="line">    <span class="keyword">return</span> huffman_code_table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上操作一番后，我们就完成了哈夫曼树的构建与哈夫曼编码表的构建。一个伟大的数据压缩算法就得以实现了！</p><p>现在你可以运行以下示例，看其结果是否与以上所说的一致。</p><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 野漫横江 on 2022/5/17.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> weight, <span class="type">char</span> data) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data = data;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> weight, <span class="type">char</span> data, TreeNode* left, TreeNode* right) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data = data;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = left;</span><br><span class="line">        <span class="keyword">this</span>-&gt;right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">TreeNode</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;TreeNode -&gt; weight: &quot;</span> &lt;&lt;  <span class="keyword">this</span>-&gt;weight &lt;&lt; <span class="string">&quot; has been released.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 优先队列自定义排序，权重高的向后排</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(TreeNode* a, TreeNode* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;weight &gt;= b-&gt;weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出哈希表key，val到终端，用于调试</span></span><br><span class="line"><span class="comment"> * @tparam K</span></span><br><span class="line"><span class="comment"> * @tparam V</span></span><br><span class="line"><span class="comment"> * @param map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log_map</span><span class="params">(map&lt;K, V&gt;&amp; _map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; packet : _map) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;key: &quot;</span> &lt;&lt; packet.first &lt;&lt; <span class="string">&quot;, val: &quot;</span> &lt;&lt; packet.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建哈夫曼树</span></span><br><span class="line"><span class="comment"> * @param s</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造一颗哈夫曼数</span></span><br><span class="line">    <span class="comment">// 首先需要统计字符串出现的次数</span></span><br><span class="line">    map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; _map;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span>&amp; c : s) _map[c]++;</span><br><span class="line">    <span class="comment">// 使用一个优先队列来维护权值的位置关系，</span></span><br><span class="line">    priority_queue&lt;TreeNode*, vector&lt;TreeNode*&gt;, cmp&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pack : _map) &#123;</span><br><span class="line">        <span class="type">int</span> data = pack.first;</span><br><span class="line">        <span class="type">char</span> val = pack.second;</span><br><span class="line">        que.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">TreeNode</span>(val, data));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自底向上构造哈夫曼树</span></span><br><span class="line">    <span class="keyword">while</span> (que.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        TreeNode* node1 = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        TreeNode* node2 = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> weight = node1-&gt;weight + node2-&gt;weight;</span><br><span class="line">        <span class="comment">// 合并后的TreeNode使用 &#x27;\0&#x27; 区分</span></span><br><span class="line">        que.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">TreeNode</span>(weight, <span class="string">&#x27;\0&#x27;</span>, node1, node2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回哈夫曼根节点</span></span><br><span class="line">    <span class="keyword">return</span> que.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node, string path, map&lt;<span class="type">char</span>, string&gt;&amp; huffman_code_table)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) &#123;</span><br><span class="line">        huffman_code_table[node-&gt;data] = path;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(node-&gt;left, path + <span class="string">&quot;0&quot;</span>, huffman_code_table);</span><br><span class="line">    <span class="built_in">dfs</span>(node-&gt;right, path + <span class="string">&quot;1&quot;</span>, huffman_code_table);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对哈夫曼树进行深度遍历构建哈夫曼编码</span></span><br><span class="line"><span class="comment"> * @param root 哈夫曼树根节点</span></span><br><span class="line"><span class="comment"> * @return 返回编码表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">map&lt;<span class="type">char</span>, string&gt; <span class="title">generate_huffman_code</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">char</span>, string&gt; huffman_code_table;</span><br><span class="line">    TreeNode* root = <span class="built_in">build</span>(s);</span><br><span class="line">    <span class="comment">// 对哈夫曼树进行深度遍历构建哈夫曼编码</span></span><br><span class="line">    <span class="built_in">dfs</span>(root, <span class="string">&quot;&quot;</span>, huffman_code_table);</span><br><span class="line">    <span class="keyword">return</span> huffman_code_table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;AAAAAABBCDDEEEEEF&quot;</span>;</span><br><span class="line">    map&lt;<span class="type">char</span>, string&gt; table = <span class="built_in">generate_huffman_code</span>(s);</span><br><span class="line">    <span class="comment">// 输出哈夫曼编码结果</span></span><br><span class="line">    <span class="built_in">log_map</span>(table);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="避免浪费"><a href="#避免浪费" class="headerlink" title="避免浪费"></a>避免浪费</h3><p>运行完示例后，你应该注意到了使用<code>new</code>申请到的内存似乎并没有被释放掉。</p><p>显然这是不负责任的行为。</p><p>所以，在我们使用<code>dfs</code>构建出<code>huffman_code_table</code>之后，应该要手动将我们亲手创建出来的整颗哈夫曼树所占据的内存释放掉。</p><p>将一整颗哈夫曼树内存释放，也就是需要遍历一整颗哈夫曼树。</p><p>我需要怎样遍历？写代码的时候我在这个问题上有些疑问。</p><p>如果我采用先序遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">release_tree_node_memory</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">    <span class="built_in">release_tree_node_memory</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">release_tree_node_memory</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，释放掉<code>node</code>后，那么<code>node</code>数据已经不存在，我就没有办法获取到<code>node-&gt;left</code>与<code>node-&gt;right</code>指针指向的内存空间，也就无法释放<code>node-&gt;left</code>与<code>node-&gt;right</code>内存空间中的内存了。</p><p>如果我采用中序遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">release_tree_node_memory</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">release_tree_node_memory</span>(root-&gt;left);</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">    <span class="built_in">release_tree_node_memory</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>精确释放了哈夫曼树所有左子数内存，保留右子数。（保左不保右，代码写的非常好，下次不要再写了）</p><p>如果我采用后序遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">release_tree_node_memory</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">release_tree_node_memory</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">release_tree_node_memory</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>芜湖！自底向上释放了一整颗二叉树！大工告成，✌️！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 野漫横江 on 2022/5/17.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> weight, <span class="type">char</span> data) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data = data;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> weight, <span class="type">char</span> data, TreeNode* left, TreeNode* right) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data = data;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = left;</span><br><span class="line">        <span class="keyword">this</span>-&gt;right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">TreeNode</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;TreeNode -&gt; weight: &quot;</span> &lt;&lt;  <span class="keyword">this</span>-&gt;weight &lt;&lt; <span class="string">&quot; has been released.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 优先队列自定义排序，权重高的向后排</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(TreeNode* a, TreeNode* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;weight &gt;= b-&gt;weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出哈希表key，val到终端，用于调试</span></span><br><span class="line"><span class="comment"> * @tparam K</span></span><br><span class="line"><span class="comment"> * @tparam V</span></span><br><span class="line"><span class="comment"> * @param map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log_map</span><span class="params">(map&lt;K, V&gt;&amp; _map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; packet : _map) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;key: &quot;</span> &lt;&lt; packet.first &lt;&lt; <span class="string">&quot;, val: &quot;</span> &lt;&lt; packet.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自底向上释放TreeNode的内存空间</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">release_tree_node_memory</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">release_tree_node_memory</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">release_tree_node_memory</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建哈夫曼树</span></span><br><span class="line"><span class="comment"> * @param s</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造一颗哈夫曼数</span></span><br><span class="line">    <span class="comment">// 首先需要统计字符串出现的次数</span></span><br><span class="line">    map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; _map;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span>&amp; c : s) _map[c]++;</span><br><span class="line">    <span class="comment">// 使用一个优先队列来维护权值的位置关系，</span></span><br><span class="line">    priority_queue&lt;TreeNode*, vector&lt;TreeNode*&gt;, cmp&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pack : _map) &#123;</span><br><span class="line">        <span class="type">int</span> data = pack.first;</span><br><span class="line">        <span class="type">char</span> val = pack.second;</span><br><span class="line">        que.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">TreeNode</span>(val, data));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自底向上构造哈夫曼树</span></span><br><span class="line">    <span class="keyword">while</span> (que.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        TreeNode* node1 = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        TreeNode* node2 = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> weight = node1-&gt;weight + node2-&gt;weight;</span><br><span class="line">        <span class="comment">// 合并后的TreeNode使用 &#x27;\0&#x27; 区分</span></span><br><span class="line">        que.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">TreeNode</span>(weight, <span class="string">&#x27;\0&#x27;</span>, node1, node2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回哈夫曼根节点</span></span><br><span class="line">    <span class="keyword">return</span> que.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node, string path, map&lt;<span class="type">char</span>, string&gt;&amp; huffman_code_table)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) &#123;</span><br><span class="line">        huffman_code_table[node-&gt;data] = path;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(node-&gt;left, path + <span class="string">&quot;0&quot;</span>, huffman_code_table);</span><br><span class="line">    <span class="built_in">dfs</span>(node-&gt;right, path + <span class="string">&quot;1&quot;</span>, huffman_code_table);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对哈夫曼树进行深度遍历构建哈夫曼编码</span></span><br><span class="line"><span class="comment"> * @param root 哈夫曼树根节点</span></span><br><span class="line"><span class="comment"> * @return 返回编码表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">map&lt;<span class="type">char</span>, string&gt; <span class="title">generate_huffman_code</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">char</span>, string&gt; huffman_code_table;</span><br><span class="line">    TreeNode* root = <span class="built_in">build</span>(s);</span><br><span class="line">    <span class="comment">// 对哈夫曼树进行深度遍历构建哈夫曼编码</span></span><br><span class="line">    <span class="built_in">dfs</span>(root, <span class="string">&quot;&quot;</span>, huffman_code_table);</span><br><span class="line">    <span class="built_in">release_tree_node_memory</span>(root); <span class="comment">// 将root所引用的所用指针指向的内存空间全部释放</span></span><br><span class="line">    <span class="keyword">return</span> huffman_code_table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;AAAAAABBCDDEEEEEF&quot;</span>;</span><br><span class="line">    map&lt;<span class="type">char</span>, string&gt; table = <span class="built_in">generate_huffman_code</span>(s);</span><br><span class="line">    <span class="comment">// 输出哈夫曼编码结果</span></span><br><span class="line">    <span class="built_in">log_map</span>(table);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TreeNode -&gt; weight: 6 has been released.</span><br><span class="line">TreeNode -&gt; weight: 5 has been released.</span><br><span class="line">TreeNode -&gt; weight: 2 has been released.</span><br><span class="line">TreeNode -&gt; weight: 1 has been released.</span><br><span class="line">TreeNode -&gt; weight: 1 has been released.</span><br><span class="line">TreeNode -&gt; weight: 2 has been released.</span><br><span class="line">TreeNode -&gt; weight: 2 has been released.</span><br><span class="line">TreeNode -&gt; weight: 4 has been released.</span><br><span class="line">TreeNode -&gt; weight: 6 has been released.</span><br><span class="line">TreeNode -&gt; weight: 11 has been released.</span><br><span class="line">TreeNode -&gt; weight: 17 has been released.</span><br><span class="line">key: A, val: 0</span><br><span class="line">key: B, val: 110</span><br><span class="line">key: C, val: 11101</span><br><span class="line">key: D, val: 1111</span><br><span class="line">key: E, val: 10</span><br><span class="line">key: F, val: 11100</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="碎碎话"><a href="#碎碎话" class="headerlink" title="碎碎话"></a>碎碎话</h3><p>这篇文章用了两天时间完成。</p><p>今天在超算上装klayout，由于没有root权限，所以只好clone 源码进行编译安装，没想到居然能编译4个小时，一下午天都黑了，漫长的等待，于是一边写文章，一边看编译是否完成。</p><p>没想到文章还没写完，最担心的事情还是发生了，它居然报错了…心中五味杂陈，成年人的崩溃就在一瞬间，一时间难以接受这样的事实。只好先把这篇写完，再去尝试问题如何解决。痛，实在太痛了！</p><p>写到这里就结束了，但还想再罗嗦一句。</p><blockquote><p><code>cmake</code>，🐶都不用！</p><p><em>——class-undefined</em></p></blockquote><p><em>2022年5月18日 于寝室 被环境配置折磨 奄奄然</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 十万个为什么 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为何大文件的移动速度会更快?</title>
      <link href="/posts/63144d9879fc/"/>
      <url>/posts/63144d9879fc/</url>
      
        <content type="html"><![CDATA[<h3 id="为何整个大文件的移动速度会更快"><a href="#为何整个大文件的移动速度会更快" class="headerlink" title="为何整个大文件的移动速度会更快?"></a>为何整个大文件的移动速度会更快?</h3><blockquote><p>扇区是对磁盘进行物理读写的最小单位。Windows中使用的磁盘，一般1个扇区是512字节。不过，Windows在逻辑方面（软件方面）对磁盘进行读写的单位是扇区整数倍簇。根据磁盘容量的不同，1簇可以是512字节（1簇&#x3D;1扇区）、1KB（1簇&#x3D;2扇区）、2KB、4KB、8KB、16KB、32KB（1簇&#x3D;64扇区）。磁盘的容量越大，簇的容量也越大。不过，在软盘中，1簇&#x3D;512字节&#x3D;1扇区，簇和扇区的大小是相等的。</p><p>不管是硬盘还是软盘，不同的文件是不能存储在同一个簇中的，否则就会导致只有一方的文件不能被删除。因此，不管是多么小的文件，都会占用1簇的空间。这样一来，所有的文件都会占用1簇的整数倍的磁盘空间。<br>因为整个大文件在磁盘上是连续存储，而且使用到的簇最少，所以读写更快。</p><p>当一个文件夹里边特别多小文件的时候，他可能不是连续的，而且可能使用到的簇多于前者，故磁盘寻址需要的时间可能是倍于前者（机械硬盘为了找到其他扇区可能会重新调整位置旋转），所以对文件压缩一下之后形成一个整体后，传输速度会更快。</p></blockquote><p>由此可见, <code>node_modules</code>确实是全宇宙中”<strong>最重</strong>“的东西…</p><p><img src="https://pic.imgdb.cn/item/628776bc09475431295fc8c9.jpg" alt="全宇宙最重的东西"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 十万个为什么 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 10- II. 青蛙跳台阶问题</title>
      <link href="/posts/cf29e1ae2103/"/>
      <url>/posts/cf29e1ae2103/</url>
      
        <content type="html"><![CDATA[<h4 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a><a href="https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></h4><ul><li><a href="#%E7%A2%8E%E7%A2%8E%E5%BF%B5">碎碎念</a></li><li><a href="#%E8%A7%A3%E6%9E%90">解析</a></li><li><a href="#%E5%A6%82%E4%BD%95%E8%A7%84%E5%88%92">如何规划？</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li><li><a href="#%E6%9D%82%E8%B0%88">杂谈</a></li><li><a href="#%E7%A2%8E%E7%A2%8E%E8%AF%9D">碎碎话</a><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p></blockquote></li></ul><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= n &lt;= 100</span><br></pre></td></tr></table></figure><h3 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h3><p>今天是2022年的5月14日， 周六</p><p>最近总觉得自己学习的效率不太高，一直在寻找一种比较适合自己的方式。一直以来我都懒于做时间规划，这也导致我做事经常不能够集中。所以也尝试每天列一些Todo清单，完成以后就把它✅掉，于是在做一天事下来后发现，原来自己每天完成的东西还是挺多的。（成就感油然而生！）</p><p>倒霉的是可能最近跑步过余猛烈，右脚现在生疼，不便走路。于是约好今天去划船。（好像并没有因果关系，不过来三亚三年，也没有真正玩过这边的水。这座城市承载了我三年记忆，而我却从未感受到它多少的存在，我见的最多的是屏幕上的字符，它的山水烟火，很遗憾没能使我驻足，并不需要依靠什么自制力，单单朴素的钱包就足够抵御这样的吸引… 如今不久就要离开这座城市，而日后朋友们也都相继离开，他们走后，我大抵不会有多大机会再回到这片承载了我三年记忆的城市了。）</p><p>所以趁这不太久的时间，尽量体会一下这片风土人情吧。</p><p>感慨就说到这里，白天还是继续学习吧，我来聊聊困惑我长久的动态规划。（事实上就在写了这篇文章时，我仍然对着块没有多大的顿悟，仅有一些经验）</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>这是一道经典的动态规划题目。经典到没有解析。X</p><p>首先，如何想到使用动态规划？（当然我在没练动态规划之前肯定是想不到这个的）</p><p>动态规划最首要的特征是，当前的状态是可以通过之前的状态推算的，是逐级递推的。所以，如果有题目能够满足这样的条件，那么它大抵是能够使用动态规划的思路去解决。</p><p>在这题中，青蛙可以一次可以跳上1级台阶，也可以一次跳上2级台阶。</p><p>那么则有：</p><table><thead><tr><th>n</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>ans</td><td>1</td><td>2</td><td>3</td><td>5</td><td>8</td></tr></tbody></table><p>看着有点像斐波那契数列对吧，事实上确实是。</p><p>那么为什么会这样，我们来捋一捋，看看能不能发现什么规律。</p><p>n&#x3D;1</p><ul><li><p>只需要跳一个台阶。次数为1</p><p>总次数为1</p></li></ul><p>n&#x3D;2</p><ul><li><p>一次跳2个台阶，次数为1</p></li><li><p>在n为1的基础上再跳1个台阶，n为1的次数为1，所以该次数也为1</p><p>所以总次数为2</p></li></ul><p>n&#x3D;3</p><ul><li><p>在n为1的基础上跳2个台阶，n为1的次数为1，所以该次数也为1</p></li><li><p>在n为2的基础上跳1个台阶，然而n为2有两种情况，所以该次数为2</p><p>所以总次数为3</p></li></ul><p>n&#x3D;4</p><p>​由于青蛙一次最多只能跳2个台阶，这意味着n&#x3D;4时，它的落脚前最近的位置是在n&#x3D;2，（n&#x3D;1时青蛙最多只能到达3）这个应该能够理解，未来忘记了思路的自己，再看到这道题，有没有恍然大悟的感觉（我会庆幸此时写下文章的自己）。</p><ul><li><p>在n为2的基础上跳2个台阶，n为2的次数为2，所以该次数也为2</p></li><li><p>在n为3的基础上跳1个台阶，然而n为3有3种情况，所以该次数为3</p><p>所以总次数为5</p></li></ul><p>n&#x3D;5</p><p>n&#x3D;6</p><p>…</p><p>如此。是否会有点感觉呢。</p><p>注意一点，这种句式可能会使我的解释给人造成误导，即</p><blockquote><p>在<code>n</code>为<code>x</code>的基础上跳<code>x</code>个台阶，<code>n</code>为<code>x</code>的次数为<code>k</code>，所以该次数也为<code>k</code></p></blockquote><p>你可能会疑惑为什么也是<code>k</code>，而不是<code>k + 1</code>呢，因为我初学动态规划也会有这样的疑问，并且在最近我才想到合理的解释，也许是悟性不够吧。</p><p>所以这个疑问的答案是什么呢？</p><p>我的回答是，向来如此。是的，它本应该就是这样的。（废话）</p><p>因为，当<code>n = 4</code>时，若此时🐸在第2级台阶，它要达到4，那么它必须跳2级，这个数列的可能性在给出<code>n</code>时，就已经确定了。</p><p>举例，</p><p>先给出<code>n = 2</code>，<code>n = 3</code>的可能性，这里<code>step</code>代表其跳到指定台阶的不同步数方案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">2</span></span><br><span class="line">step = [[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">step = [[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>那么<code>n = 4</code>则有（用我在上方列举的情况做对比）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">4</span> </span><br><span class="line">step_by_2 = [[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">2</span>]] <span class="comment"># 在 n = 2的基础上有</span></span><br><span class="line">step_by_3 = [[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>]] <span class="comment"># 在 n = 3的基础上有</span></span><br><span class="line">step = [[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>]] <span class="comment"># 两者合并即所有情况</span></span><br></pre></td></tr></table></figure><p>所以，也就不存在+1一说，因为若要到达<code>n</code>级台阶，那么它本就是这样发展的。若在2级台阶时，<code>step = [1, 1]</code>那么下一步就必然是2，<code>step = [1, 1, 2]</code>，它是一个整体，逻辑上与2级台阶的<code>step = [1, 1]</code>等同，仅仅是<code>step</code>数列长度不一样，这个长度不一样是其台阶级数决定的，仅此而已。若+1，就没有意义了。（如果还是不能理解我说的意思，需要自己去悟了，我无法用更好的语言表达了，为此我深感抱歉）</p><h3 id="如何规划？"><a href="#如何规划？" class="headerlink" title="如何规划？"></a>如何规划？</h3><p>由上部分的解析我们已经可以知道，当前台阶的步数仅与前两次台阶计数的步数有关。</p><p>约定一个长度为<code>n</code>的数组<code>dp</code>，规定<code>dp[i]</code>为青蛙跳到第<code>i</code>级台阶的跳法。由于以上的分析我们不难知道，当前台阶的跳法为前两个的台阶的跳法之和。</p><p>即<code>dp[i] = dp[i - 1] + dp[i - 2]</code>，这就是本题动态规划的状态转移方程，没错，就是斐波那契的表达式。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numWays</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span>* dp = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mod = <span class="number">1000000007</span>; <span class="comment">// 题目要求取模，否则n过大则答案会溢出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = (dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]) % mod; <span class="comment">// 状态转移方程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n]; <span class="comment">// 递推到n即为答案</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h3><p>今天去体验了一番游艇，还下潜游了一会。想着以后这座城市的日子已进入倒计时，第一次踏入这片土地的场景仍印在脑海，心中仍然有些唏嘘。我总是这样的怀旧，曾经的日子距离今天越久，仿佛那些日子相比于今天就越快乐。这不好。</p><p>Anyway，今天也很快乐。</p><h3 id="碎碎话"><a href="#碎碎话" class="headerlink" title="碎碎话"></a>碎碎话</h3><blockquote><p>无知的少年依旧无知，追寻的人生依旧还在路上。</p></blockquote><p>2022年5月14日 星期六 江南四大才子出海顺利归来 于寝室。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 力扣那些事 </tag>
            
            <tag> 强化训练 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>433. 最小基因变化</title>
      <link href="/posts/cc13ad4d4e72/"/>
      <url>/posts/cc13ad4d4e72/</url>
      
        <content type="html"><![CDATA[<h4 id="433-最小基因变化"><a href="#433-最小基因变化" class="headerlink" title="433. 最小基因变化"></a><a href="https://leetcode.cn/problems/minimum-genetic-mutation/">433. 最小基因变化</a></h4><ul><li><a href="#%E7%A4%BA%E4%BE%8B1">示例1:</a></li><li><a href="#%E7%A2%8E%E7%A2%8E%E5%BF%B5">碎碎念</a></li><li><a href="#%E8%A7%A3%E6%9E%90">解析</a></li><li><a href="#%E5%A6%82%E4%BD%95%E4%B8%8B%E6%89%8B">如何下手？</a></li><li><a href="#%E6%88%91%E7%9A%84%E6%AD%A6%E5%99%A8%E5%9C%A8%E9%82%A3%E9%87%8C">我的武器在那里？</a></li><li><a href="#%E5%85%B7%E4%BD%93">具体？</a></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li><li><a href="#%E6%9D%82%E8%B0%88">杂谈</a></li><li><a href="#%E7%A2%8E%E7%A2%8E%E8%AF%9D">碎碎话</a><blockquote><p>基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是<code> &#39;A&#39;</code>、<code>&#39;C&#39;</code>、<code>&#39;G&#39;</code> 和 <code>&#39;T&#39;</code> 之一。</p><p>假设我们需要调查从基因序列 <code>start </code>变为 <code>end</code> 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。</p><p>例如，<code>&quot;AACCGGTT&quot; --&gt; &quot;AACCGGTA&quot; </code>就是一次基因变化。<br>另有一个基因库<code>bank</code>记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。</p><p>给你两个基因序列 <code>start</code> 和<code>end</code>，以及一个基因库<code> bank</code> ，请你找出并返回能够使<code>start</code>变化为 <code>end</code> 所需的最少变化次数。如果无法完成此基因变化，返回<code> -1</code> 。</p><p>注意：起始基因序列 <code>start </code>默认是有效的，但是它并不一定会出现在基因库中。</p></blockquote></li></ul><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：start = &quot;AACCGGTT&quot;, end = &quot;AACCGGTA&quot;, bank = [&quot;AACCGGTA&quot;]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>篇幅有限，这里只给出一个示例。</p><h3 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h3><p>今天是2022年的5月7日，在此日的0点，看过了这题，是当日的每日一题，粗略的看了一眼题目，思来想去，横竖无头绪，只在字里行间看到两个字，回溯。思考了一会，发现不止如何下手。遂看题解，由于当时已无心学习，在电子书与力扣反复切换，作罢。这个懒狗居然将疑问抛给早晨后的自己…怎么睡得着的（一大早就被空调冻醒）。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>题目的大意是，给定一个初始基因序列<code>start</code>，在符合特定条件的前提下，每次可用修改<code>start</code>的其中的一个字符，直到<code>start</code>与<code>end</code>相等，求最少的更改次数。</p><p>特定条件为：</p><ul><li><p>更改的字符必须是<code> &#39;A&#39;</code>、<code>&#39;C&#39;</code>、<code>&#39;G&#39;</code> 和 <code>&#39;T&#39;</code> 之一。</p></li><li><p>每一次更改字符后形成的字符串必须存在于<code>bank</code>数组当中。</p><p>举个例子：若<code> start = &quot;AACCGGTT&quot;</code>, <code>end = &quot;AACCGGCA&quot;</code>, <code>bank = [&quot;AACCGGCA&quot;, &quot;AACCGGTA&quot;]</code>，在这个例子当中，修改<code>start</code>字符串并不是<code> &#39;A&#39;</code>、<code>&#39;C&#39;</code>、<code>&#39;G&#39;</code> 、 <code>&#39;T&#39;</code>中任意一个替换都可以的。我将修改之后的字符串命名为<code>next</code>。那么<code>next</code>必须是<code>bank</code>中的元素。</p><p>也就是说，在这个例子下，改法步骤有且仅有两种。</p><p>第一步，<code>start = &quot;AACCGGTT&quot;</code> -&gt; <code>next = &quot;AACCGGTA&quot;</code>，而不能 <code>start = &quot;AACCGGTT&quot;</code> -&gt; <code>next = &quot;AACCGGTC&quot;</code> or <code>next = &quot;AACCGGTG&quot;</code>等等，因为<code>&quot;AACCGGTC&quot;</code>与<code>&quot;AACCGGTG&quot;</code>并不是<code>bank</code>中的元素。</p><p>同理，第二步就只能是<code>&quot;AACCGGTA&quot;</code> -&gt; <code>&quot;AACCGGCA&quot;</code>。</p><p>最终修改次数，即为<code>2</code>。</p><p>说到这里，应该大致明了题目意思了。</p></li></ul><p>所以，我应该怎么做？未看题解之前，我完全没有想到，这其实是一个图论问题，抽象出来其实是在求图的最小路径长度。</p><h3 id="如何下手？"><a href="#如何下手？" class="headerlink" title="如何下手？"></a>如何下手？</h3><p>图的遍历方式有dfs和bfs，这两种都可以解决这个问题，但显然bfs会比较清晰明了。我可用把<code>start</code>与修改的每一个<code>next</code>抽象成一颗N叉树。</p><p>举个例子：</p><p>若例子为<code>start = &quot;AAAAACCC&quot;, end = &quot;AACCCCCC&quot;, bank = [&quot;AAAACCCC&quot;,&quot;AAACCCCC&quot;,&quot;AACCCCCC&quot;, &quot;AAAATCCC&quot;]</code></p><p>那么其结构就是这样：</p><p><img src="https://pic.imgdb.cn/item/62877a0d094754312961ccf1.png" alt="结构"></p><p>显然，最小变化次数为<code>3</code>次。</p><p>那么利用bfs，我就可用逐层的遍历可能的修改，这样，一旦某一层符合条件的修改字符串等于<code>end</code>，自然而然就找到了最小的修改次数（因为在此之前绝无等于<code>end</code>的情况，我总是逐层遍历的），也就是这颗N叉数的层数。仔细想想，应该没有问题。</p><h3 id="我的武器在那里？"><a href="#我的武器在那里？" class="headerlink" title="我的武器在那里？"></a>我的武器在那里？</h3><p>首先，若需要快速的知道修改的字符串是否存在与<code>bank</code>中，显然需要一个哈希表。</p><p>以及，需要判断修改的字符串是否以及遍历过了，需要有一个<code>visited</code>记录，同样也用哈希表存储。</p><p>当然，也要有用于枚举修改可能性的<code>char cells[4] = &#123;&#39;A&#39;, &#39;C&#39;, &#39;G&#39;, &#39;T&#39;&#125;;</code></p><p>最后，bfs必备的队列。</p><h3 id="具体？"><a href="#具体？" class="headerlink" title="具体？"></a>具体？</h3><p>依据题目意思，当初始情况下<code>start</code>若与<code>end</code>相等，则无需做任何处理。直接<code>return 0;</code></p><p>否则，我们需要建立一个哈希表来方便查询字符串是否存在于<code>bank</code>，以及需要维护一个<code>visited</code>记录是否访问过修改的元素。</p><p>如果end不存在于bank，那么代表着修改的结果不可能会end相等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unordered_set&lt;string&gt; cnt; <span class="comment">// 用于查询元素是否存在于bank</span></span><br><span class="line">unordered_set&lt;string&gt; visited; <span class="comment">// 记录是否访问过修改的元素。</span></span><br><span class="line"><span class="type">char</span> cells[<span class="number">4</span>] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;T&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; s : bank) cnt.<span class="built_in">insert</span>(s); <span class="comment">// 将bank中的元素添加到cnt中</span></span><br><span class="line"><span class="keyword">if</span> (cnt.<span class="built_in">count</span>(end) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 如果end不存在于bank，那么代表着修改的结果不可能会end相等。</span></span><br></pre></td></tr></table></figure><p>之后，就是进行bfs搜索，一旦遇到修改字符串与<code>end</code>相等的情况，那么就输出当前的层数，否则，当bfs搜索完毕依然未找到结果，则代表<code>bank</code>所给出的路径无法到达<code>end</code>。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMutation</span><span class="params">(string start, string end, vector&lt;string&gt;&amp; bank)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;string&gt; cnt; <span class="comment">// 用于查询元素是否存在于bank</span></span><br><span class="line">        unordered_set&lt;string&gt; visited; <span class="comment">// 记录是否访问过修改的元素。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; s : bank) cnt.<span class="built_in">insert</span>(s); <span class="comment">// 将bank中的元素添加到cnt中</span></span><br><span class="line">        <span class="keyword">if</span> (cnt.<span class="built_in">count</span>(end) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 如果end不存在于bank，那么代表着修改的结果不可能会end相等。</span></span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(start);</span><br><span class="line">        visited.<span class="built_in">insert</span>(start);</span><br><span class="line">        <span class="type">char</span> cells[<span class="number">4</span>] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;T&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">int</span> step = <span class="number">1</span>; <span class="comment">// 记录bfs搜索层数</span></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; size; k++) &#123;</span><br><span class="line">                string node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (node[i] == cells[j]) <span class="keyword">continue</span>;</span><br><span class="line">                        string next = node;</span><br><span class="line">                        next[i] = cells[j];</span><br><span class="line">                        <span class="keyword">if</span> (cnt.<span class="built_in">count</span>(next) &amp;&amp; !visited.<span class="built_in">count</span>(next)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (next == end) <span class="keyword">return</span> step;</span><br><span class="line">                            visited.<span class="built_in">insert</span>(next);</span><br><span class="line">                            q.<span class="built_in">push</span>(next);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h3><p>截止到2022年5月7日，如今力扣也刷过了374道。可能说出这样的成绩，也会有人觉得我是一个很算法还不错的人。我也希望，但事实并不如此。在多的数量胜不了质量的稳健，也许简单难度我可以立马想到并且写出，稍微变化一下的中等题目也许我也会踌躇良久，面对周赛，甚至也只能AC过一个签到题。</p><p>我并不抱怨，事实上如今的成绩也会让我很欣慰，毕竟在一年之前，我甚至通不过它的简单水平。很奇妙，当初拍脑袋就去做的事情转眼就坚持了将近一年，这让我看到了无限可能，虽然水平尚不突出，但是我的目的已经达到了，面对算法，我已不再恐惧。</p><p>我不试图在一个短时间内取得怎样成绩，如果想改变一些东西，不妨将这件事细分到每天的一件小事。没有多少人做得到坚持一件对自己来说十分厌恶的事情，如果决心要坚持它，不妨先学会热爱，没有热爱的坚持，是在折磨自己。细水长流，源远流长，我对一步登天不抱有幻想，无心插柳才是最适合的方式。</p><p>这一年学会了很多东西，对于明天，要一直抱有期待。（当兴趣变成了工作，也可以说是相当痛苦的事情）</p><p>anyway，感谢Github，让我实现了创作自由~</p><h3 id="碎碎话"><a href="#碎碎话" class="headerlink" title="碎碎话"></a>碎碎话</h3><blockquote><p>对于我身上那些奇怪的光环，它并不属于我。我本林中之鸟，需要时刻保持谦卑。</p></blockquote><p><em>2022年5月7日于三院图书馆 欲去北一吃午饭，正小雨，无伞，待雨停</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 力扣那些事 </tag>
            
            <tag> 比昨天变强一点点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态内部是如何实现的</title>
      <link href="/posts/9dc5721aa727/"/>
      <url>/posts/9dc5721aa727/</url>
      
        <content type="html"><![CDATA[<h1 id="多态内部是如何实现的"><a href="#多态内部是如何实现的" class="headerlink" title="多态内部是如何实现的"></a>多态内部是如何实现的</h1><p>这两天一直在寻找这方面的信息,发现这个问题我起得太大了. </p><p>对于C++来说，多态是靠虚函数实现的，所以问题就转变为虚函数的相关机制。当一个类中定义了一个或以上的虚函数，C++就会为这个类创建一个虚函数表（<code>vtable</code>），而指向这个虚函数表内存的指针则会存放在这个类的内存当中。当派生类调用重写的虚函数方法，程序内部就会根据这个类的虚函数表查找对应的虚函数，本质上就是传递了这个<code>vtable</code>指针，借助这个指针来判断是调用父类的虚函数还是派生出来的子类虚函数。所以也可以知道，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的，它是动态调用的。</p><p>这里引用了几篇回答。</p><blockquote><p>多态的最根本好处在于，你不必再向对象询问“你是什么类型”而后根据得到的答案调用对象的 某个行为一你只管调用该行为就是了，其他的一切多态机制都会为你安排妥当。</p><p>——《重构：改善既有代码的设计》</p></blockquote><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       cout&lt;&lt;<span class="string">&quot;A::foo() is called&quot;</span>&lt;&lt;endl;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">   </span>&#123;  </span><br><span class="line">       cout&lt;&lt; <span class="string">&quot;B::foo() is called&quot;</span> &lt;&lt;endl;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   A *a = <span class="keyword">new</span> <span class="built_in">B</span>();  </span><br><span class="line">   a-&gt;<span class="built_in">foo</span>();   <span class="comment">// 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!  </span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子是虚函数的一个典型应用，通过这个例子，也许你就对虚函数有了一些概念。它虚就虚在所谓“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。</p><p>​    虚函数只能借助于指针或者引用来达到多态的效果。</p><p>作者：wuxinliulei</p><p>链接：<a href="https://www.zhihu.com/question/23971699/answer/69592611">https://www.zhihu.com/question/23971699/answer/69592611</a></p><p>来源：知乎</p></blockquote><blockquote><p>C++ 编译器必须为每一个多态类至少创建一个【虚函数表（vtable）】，其本质是一个【函数指针数组】，其中存放着这个类所有的【虚函数的地址】及该类的类型信息，其中也包括那些【继承但未改写（Override）的虚函数】。</p><p>——林锐博士《高质量程序设计指南第三版》</p></blockquote><h2 id="如何证明C-创建了虚函数表？"><a href="#如何证明C-创建了虚函数表？" class="headerlink" title="如何证明C++创建了虚函数表？"></a>如何证明C++创建了虚函数表？</h2><p>该标题下为CSDN博主「annjeff」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/annjeff/article/details/106734773">https://blog.csdn.net/annjeff/article/details/106734773</a></p><p>这是一个C++空类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl; <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么-C-空类大小是-1"><a href="#为什么-C-空类大小是-1" class="headerlink" title="为什么 C++ 空类大小是 1 ?"></a>为什么 C++ 空类大小是 1 ?</h3><blockquote><p>C++ 不允许任何一个对象大小为 0 ，因为这样无法为该变量分配存储空间。<br>当类为空时，C++ 编译器会向其中插入一个字节的数据，因此空类类型大小为 1 字节。</p></blockquote><h3 id="C-非空类大小"><a href="#C-非空类大小" class="headerlink" title="C++ 非空类大小"></a>C++ 非空类大小</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl; <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>就本例而言，因为此时 A 含有一个 int 型成员变量，因此编译器不会再给 A 类增加 1 个的数据，所以本例 A 的大小为 4。</p><p>总体而言，一个不含虚函数的类，类的大小是【大于或等于】类内所有非静态成员变量的总和。因为存在内存对齐问题，因此可能会大于非静态成员总和。</p></blockquote><h3 id="成员函数是否占用类的大小？"><a href="#成员函数是否占用类的大小？" class="headerlink" title="成员函数是否占用类的大小？"></a>成员函数是否占用类的大小？</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl; <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由本例可知，非虚成员函数，不占用类的大小。</p></blockquote><h3 id="含虚函数的类的大小"><a href="#含虚函数的类的大小" class="headerlink" title="含虚函数的类的大小"></a>含虚函数的类的大小</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfun</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl; <span class="comment">//32 位机器 大小为 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本例中，类型 A 的大小为 4 。此时类为空类，按理讲应该是 大小为 1。而此时不为 1 ，说明类中含有别的成员&#x3D;&#x3D;&gt; 此处正是 <strong>指向【虚函数表】的指针 【* __vptr】</strong> 所占用的存储空间。</p></blockquote><h3 id="含多个虚函数的类大小"><a href="#含多个虚函数的类大小" class="headerlink" title="含多个虚函数的类大小"></a>含多个虚函数的类大小</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfun1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl; <span class="comment">//32 位机器 大小为 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>此处可以得知，<strong>虚函数不占用类对象的存储空间</strong>，所以含有一个以上的虚函数的类对象大小与仅含一个虚函数大小相同。因为：<strong>针对每个类，只维护一个【虚函数表（函数指针数组数组）】用于存放该类中虚函数的地址，每个【含一个及以上虚函数的对象都会含有一个指向该类虚函数表的指针】</strong>。</p></blockquote><h3 id="非虚函数例子"><a href="#非虚函数例子" class="headerlink" title="非虚函数例子"></a>非虚函数例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;D func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B* b = <span class="keyword">new</span> B;</span><br><span class="line">    b-&gt;<span class="built_in">func</span>();<span class="comment">// label1:B func</span></span><br><span class="line">    D* d = <span class="keyword">new</span> D;</span><br><span class="line">    d-&gt;<span class="built_in">func</span>();<span class="comment">// label2:  D func</span></span><br><span class="line">    B* pb = <span class="keyword">new</span> D;</span><br><span class="line">    pb-&gt;<span class="built_in">func</span>();<span class="comment">// label3:  B func</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>label1 处：<br>基类指针指向基类对象，自然调用基类中的函数。</p><p>label2 处：<br>派生类与基类的【函数同名时】，【子类会覆盖掉父类所有的同名函数】。 因此此处调用的是派生类中的同名函数。</p><p>label3处：<br>此时调用基类中的同名成员，因为不存虚函数故而没有动态绑定，在父类作用域下，自然调用父类的同名函数。</p></blockquote><h3 id="虚函数例子"><a href="#虚函数例子" class="headerlink" title="虚函数例子"></a>虚函数例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">VFun</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B vFunc&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;D vFunc&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B* b = <span class="keyword">new</span> B;</span><br><span class="line">    b-&gt;<span class="built_in">vFunc</span>();<span class="comment">// label1:B vFunc</span></span><br><span class="line">    D* d = <span class="keyword">new</span> D;</span><br><span class="line">    d-&gt;<span class="built_in">vFunc</span>();<span class="comment">// label2:  D vFunc</span></span><br><span class="line">    B* pb = <span class="keyword">new</span> D;</span><br><span class="line">    pb-&gt;<span class="built_in">vFunc</span>();<span class="comment">// label3:  D vFunc</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>label1 处：基类指针指向基类对象，调用的是基类中的 vFunc</p><p>label2 处：<br>当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数。</p><p>label3 处：<br>因为 派生类【覆盖】（重写）了基类虚函数，给出了派生类的版本，此时 派生类中【虚函数表内 vFun 函数的指针替换为派生类 vFun 的函数指针】，故而由基类实现了【动态绑定】调用了子类同名函数。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 十万个为什么 </tag>
            
            <tag> 虚函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 35. 复杂链表的复制</title>
      <link href="/posts/c9909ff413e7/"/>
      <url>/posts/c9909ff413e7/</url>
      
        <content type="html"><![CDATA[<h4 id="剑指-Offer-35-复杂链表的复制"><a href="#剑指-Offer-35-复杂链表的复制" class="headerlink" title="剑指 Offer 35. 复杂链表的复制"></a><a href="https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a></h4><ul><li><a href="#%E7%A4%BA%E4%BE%8B1">示例1:</a></li><li><a href="#%E7%A2%8E%E7%A2%8E%E5%BF%B5">碎碎念</a></li><li><a href="#%E8%A7%A3%E6%9E%90">解析</a></li><li><a href="#%E7%A2%8E%E7%A2%8E%E6%83%B3">碎碎想</a></li><li><a href="#%E5%A6%82%E4%BD%95%E9%80%92%E5%BD%92">如何递归</a><ul><li><a href="#%E8%AE%BE%E8%AE%A1%E9%80%92%E5%BD%92-%E8%BF%99%E4%B8%AA%E9%80%92%E5%BD%92%E9%9C%80%E8%A6%81%E5%B9%B2%E4%BB%80%E4%B9%88%E4%BA%8B">设计递归-这个递归需要干什么事？</a></li><li><a href="#%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88">终止条件是什么</a></li><li><a href="#%E6%88%91%E7%9A%84%E6%AD%A6%E5%99%A8%E5%9C%A8%E5%93%AA%E9%87%8C">我的武器在哪里？</a></li><li><a href="#%E5%85%B7%E4%BD%93">具体？</a></li></ul></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li><li><a href="#%E4%B8%8D%E5%A6%A8%E5%86%8D%E5%A4%A7%E8%83%86%E4%B8%80%E4%BA%9B">不妨再大胆一些？</a></li><li><a href="#%E7%A2%8E%E7%A2%8E%E8%AF%9D">碎碎话</a></li></ul><blockquote><p>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p></blockquote><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h3><p><img src="/./../images/%E5%89%91%E6%8C%87%20Offer%2035.%20%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6-e1.png" alt="e1"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure><p>篇幅有限，这里只给出一个示例。</p><h3 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h3><p>现在时间是2022年的5月6号，在此年的3月28号我写过了这题。但今天看到这题我又忘记该怎么写了，说到底还是学得不够透。所以借着这个机会深度总结一下。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>如果不知道题目的意思。我应该可以进一步解释，我明白，链表的指向（这里指<code>next</code>、<code>random</code>）都是指针，也就是一个对象的引用，所以，我不可以简单的进行一个赋值操作，因为对于一个引用，赋值仅仅是传递了一个内存地址，用试图用原先的指针赋值给一个新指针，那么此时新指针指向的依然还是原对象，也就是说，这样的拷贝操作是毫无作用的。</p><blockquote><p>所以，简单来说，题目需要我复刻它给出的指针，它需要一个值与原链表相同，但是内存地址与原链表完全不同的链表结构，也就是进行一次链表的深拷贝。</p></blockquote><p>看到这题，我的第一反映就是递归。这个应该很容易联想。以<code>示例1</code>为例，如果我需要复刻结点7那么我们就需要复刻7指向的<code>next</code>和<code>random</code>，同理，如果要复刻7的<code>next</code>，那么就需要复刻7的<code>next</code>的<code>next</code>，7的<code>next</code>的<code>random</code>…很显然，发现了这就是个套娃，所以这就很适合递归，nice。可是，我该怎么递归，我在这里迷失了。</p><h3 id="碎碎想"><a href="#碎碎想" class="headerlink" title="碎碎想"></a>碎碎想</h3><p>其实，我可以把这题的链表想象成是一个颗二叉树。<code>next</code>、<code>random</code>就看作是其的左右结点。</p><p>因为，做了这么多题，看了这么多的题解与指南，我已知道，在图论中，图结构本身其实也是树结构，它只不过是一颗N叉树。所以代入此题，我不用在意这个<code>random</code>随机指向，它的随机完全没有问题，是合理的。所以，我应该怎么递归呢。</p><h3 id="如何递归"><a href="#如何递归" class="headerlink" title="如何递归"></a>如何递归</h3><h4 id="设计递归-这个递归需要干什么事？"><a href="#设计递归-这个递归需要干什么事？" class="headerlink" title="设计递归-这个递归需要干什么事？"></a>设计递归-这个递归需要干什么事？</h4><p>我希望当我传入一个链表结点后，它能够将链表进行一次深拷贝，并将深拷贝后的新结点返回给我。</p><p>举个例子，假设有单链表<code>7-&gt;13-&gt;11-&gt;null</code>，如图</p><p><img src="https://pic.imgdb.cn/item/628777840947543129603808.png" alt="DFC2850DF3C5D15432E9CF490884CAE9"></p><h4 id="终止条件是什么"><a href="#终止条件是什么" class="headerlink" title="终止条件是什么"></a>终止条件是什么</h4><p>首先，提到递归，我应该本能的想到需要有一个<code>base case</code>，也就是需要有一个终止递归的条件，告诉它，这条路已经走到头了，不要无休止的陷入递归。<code>stackoverflow警告⚠️</code></p><p>那么这个<code>base case</code>是什么呢？这个也很容易想到，当传入的链表结点为<code>null</code>时，这条分支路径就递归到头了，那么我们返回的也应该是<code>null</code> *(在C&#x2F;C++中为<code>nullptr</code> or <code>NULL</code>)*，这个应该很好理解。</p><h4 id="我的武器在哪里？"><a href="#我的武器在哪里？" class="headerlink" title="我的武器在哪里？"></a>我的武器在哪里？</h4><p>那么之后我还要做什么，对于每一次深拷贝后的结点，我需要有个东西对它进行储存，否则我无法拿到<code>random</code>指向的深拷贝（如果在此之前我拷贝过相同结点的话）。</p><p><strong>所以，我需要有这样的结构，给予一个原先的结点，它能够得到对它进行深拷贝后的结点（如果深拷贝结点已经存在的情况话）</strong></p><p>显然，哈希表对这样的一一映射关系的存储效率得天独厚。</p><p>所以，我需要有一个<code>unordered_map&lt;Node*, Node*&gt; map</code>，我需要用它来干这件大事。</p><h4 id="具体？"><a href="#具体？" class="headerlink" title="具体？"></a>具体？</h4><p>当哈希表发现中如果已经存在原结点的新结点，我只需要返回这个新结点就可以了。</p><p>如果没有发现呢？那么我就需要<code>Node* node = new Node(val)</code>，这个<code>val</code>是原结点的<code>head-&gt;val</code>，<code>node</code>就是我们的新结点。那，新结点的<code>next</code>、<code>random</code>呢？我只需要将原结点的<code>next</code>、<code>random</code>传入我们设计这个递归函数中，其它的，全权不需要我操心了。之后返回这个结点就算完成了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; map;</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">count</span>(head)) <span class="keyword">return</span> map[head];</span><br><span class="line">        Node* node = <span class="keyword">new</span> <span class="built_in">Node</span>(head-&gt;val);</span><br><span class="line">        map[head] = node;</span><br><span class="line">        node-&gt;next = <span class="built_in">copyRandomList</span>(head-&gt;next);</span><br><span class="line">        node-&gt;random = <span class="built_in">copyRandomList</span>(head-&gt;random);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可能有些疑问，为什么是先<code>map[head] = node;</code>之后再赋值<code>node</code>的<code>next</code>与<code>random</code>呢？</p><p>先想想如果按照先赋值全部以后再将其添加的哈希表中会发生什么，答案是<code>stackoverflow</code>，无限递归了，这是为什么呢？如果脑中浅浅的执行一下你会发现，一旦遇上循环指针，我们也许在<code>map</code>中永远找不到<code>node</code>了，终止条件覆盖不到这种情况，它会一直递归下去的。</p><p><em>那为什么按代码里的顺序就可以呢？它怎么解决上述的问题？</em></p><p>原因是我们<code>Node* node = new Node(head-&gt;val);</code>在生成新结点后就进行了<code>map[head] = node;</code>将新结点存储到哈希表的操作。之后再针对原指针的<code>next</code>、<code>random</code>进行递归，即便遇上循环指针，它也会触发<code>if (map.count(head)) return map[head];</code>返回了我们创建的新结点，也就终止了递归操作。</p><p>而当新的结点返回，我们就可以顺利将<code>node-&gt;next</code>和<code>node-&gt;random</code>进行赋值操作了。</p><p>最终，所有递归调用栈弹出，返回的自然是最初的<code>node</code>，恰到好处。</p><h3 id="不妨再大胆一些？"><a href="#不妨再大胆一些？" class="headerlink" title="不妨再大胆一些？"></a>不妨再大胆一些？</h3><p>其实，对于初入编程的学习者来说，递归其实是一个比较难懂的概念，知其然却不知其所以然，至少对于我来说是这样的。这样的情况持续了相当长一段时间，一入递归深似海，从此offer为路人。其实对于递归这个概念，我并没有什么特别的好的技巧，但是经过很长一段时间的刷题思考，或是知觉使然，也逐渐有了一些经验。</p><p>经验告诉我，在学习递归时，很容易陷入递归的调用栈中挣扎，这太正常了，我们的脑袋可压不了几个调用栈。所幸，它应该总可以描述成我们可以翻译的树形结构，我们都知道程序代码是顺序执行的，所以完全可以拿起手中的草稿纸对这个调用顺序一探究竟，倒要看看它凭什么就能如此简约的解决这样的问题，但写这样的执行顺序是一定不要忘记使用缩进或其它辨别方式来表示递归的分支，否则，草稿纸一样无法拯救一个试图变强的灵魂。</p><h3 id="碎碎话"><a href="#碎碎话" class="headerlink" title="碎碎话"></a>碎碎话</h3><blockquote><p>你这一生，一定要吃够足够的苦头，才能够明白幸运一时的运气拯救不了一个学识匮乏的人生。</p></blockquote><p><em>2022年5月6日于三院图书馆</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 力扣那些事 </tag>
            
            <tag> 丢失在记忆中的算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
